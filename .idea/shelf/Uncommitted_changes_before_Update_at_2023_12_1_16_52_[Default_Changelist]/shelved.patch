Index: .idea/shelf/Uncommitted_changes_before_Update_at_2023_11_16_18_38__Default_Changelist_.xml
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_2023_11_16_18_38__Default_Changelist_.xml	(revision ccbe6e082bb4d813a76e3b81736612991f6e94c1)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_2023_11_16_18_38__Default_Changelist_.xml	(revision ccbe6e082bb4d813a76e3b81736612991f6e94c1)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_2023_11_16_18_38_[Default_Changelist]" date="1700131114481" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_2023_11_16_18_38_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 2023/11/16 18:38 [Default Changelist]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_2023_11_16_18_38_[Default_Changelist]/shelved.patch
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_2023_11_16_18_38_[Default_Changelist]/shelved.patch	(revision ccbe6e082bb4d813a76e3b81736612991f6e94c1)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_2023_11_16_18_38_[Default_Changelist]/shelved.patch	(revision ccbe6e082bb4d813a76e3b81736612991f6e94c1)
@@ -1,114 +0,0 @@
-Index: leetcode_base/bank/_2760.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- leetcode_base/bank/_2760.py	(date 1700130743876)
-+++ leetcode_base/bank/_2760.py	(date 1700130743876)
-@@ -0,0 +1,36 @@
-+from typing import List
-+
-+
-+class _1st:
-+    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
-+        n = len(nums)
-+        l, r = 0, 0
-+        ans = 0
-+        while l < n:
-+            if nums[l] % 2 == 0:
-+                r = l
-+                while r < n - 1 and nums[r] <= threshold and nums[r] % 2 != nums[r + 1] % 2:
-+                    r += 1
-+                ans = max(ans, r - l + 1)
-+            l = r + 1
-+        return ans
-+
-+
-+class _2nd:
-+    print("")
-+
-+
-+class _3rd:
-+    print("")
-+
-+
-+class _4th:
-+    print("")
-+
-+
-+if __name__ == '__main__':
-+    handlers = [_1st()]
-+    for handler in handlers:
-+        nums = [3, 2, 5, 4]
-+        threshold = 5
-+        handler.longestAlternatingSubarray(nums, threshold)
-Index: leetcode_base/bank/_2300.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- leetcode_base/bank/_2300.py	(date 1699577382392)
-+++ leetcode_base/bank/_2300.py	(date 1699577382392)
-@@ -0,0 +1,62 @@
-+from typing import List
-+
-+
-+class _1st:
-+    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
-+        n, m = len(spells), len(potions)
-+        potions.sort()
-+        ans = [0] * n
-+        # 闭区间
-+        for i in range(0, n):
-+            x = spells[i]
-+            l, r = 0, m - 1
-+            while l < r:
-+                mid = l + (r - l + 1) // 2
-+                if potions[mid] * x >= success:
-+                    r = mid - 1
-+                else:
-+                    l = mid
-+            ans[i] = m - l
-+            if x * potions[l] < success:
-+                ans[i] -= 1
-+        return ans
-+
-+
-+class _2nd:
-+    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
-+        n, m = len(spells), len(potions)
-+        potions.sort()
-+        ans = [0] * n
-+        # 开区间
-+        for i in range(0, n):
-+            x = spells[i]
-+            l, r = -1, m
-+            while l + 1 < r:
-+                mid = l + (r - l + 1) // 2
-+                if potions[mid] * x >= success:
-+                    r = mid
-+                else:
-+                    l = mid
-+            ans[i] = m - l - 1
-+        return ans
-+
-+
-+class _3rd:
-+    print("")
-+
-+
-+class _4th:
-+    print("")
-+
-+
-+if __name__ == '__main__':
-+    handlers = [_2nd()]
-+    for handler in handlers:
-+        spells = [3, 1, 2]
-+        potions = [8, 5, 8]
-+        success = 16
-+        handler.successfulPairs(spells, potions, success)
-+        # spells = [15, 8, 19]
-+        # potions = [38, 36, 23]
-+        # success = 328
-+        # handler.successfulPairs(spells, potions, success)
Index: leetcode_base/bank/_1670.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- leetcode_base/bank/_1670.py	(date 1701141536891)
+++ leetcode_base/bank/_1670.py	(date 1701141536891)
@@ -0,0 +1,72 @@
+from collections import deque
+from typing import List
+
+
+class _1st:
+    class FrontMiddleBackQueue:
+        __slots__ = 'left', 'right'
+
+        def __init__(self):
+            self.left = deque()
+            self.right = deque()
+
+        # 调整长度，保证 0 <= len(right) - len(left) <= 1
+        # 从而保证可以在正中间插入删除元素
+        def balance(self):
+            if len(self.left) > len(self.right):
+                self.right.appendleft(self.left.pop())
+            elif len(self.right) > len(self.left) + 1:
+                self.left.append(self.right.popleft())
+
+        def pushFront(self, val: int) -> None:
+            self.left.appendleft(val)
+            self.balance()
+
+        def pushMiddle(self, val: int) -> None:
+            if len(self.left) < len(self.right):
+                self.left.append(val)
+            else:
+                self.right.appendleft(val)
+
+        def pushBack(self, val: int) -> None:
+            self.right.append(val)
+            self.balance()
+
+        def popFront(self) -> int:
+            if not self.right:  # 整个队列为空
+                return -1
+            val = self.left.popleft() if self.left else self.right.popleft()
+            self.balance()
+            return val
+
+        def popMiddle(self) -> int:
+            if not self.right:  # 整个队列为空
+                return -1
+            if len(self.left) == len(self.right):
+                return self.left.pop()
+            return self.right.popleft()
+
+        def popBack(self) -> int:
+            if not self.right:  # 整个队列为空
+                return -1
+            val = self.right.pop()
+            self.balance()
+            return val
+
+
+class _2nd:
+    print("")
+
+
+class _3rd:
+    print("")
+
+
+class _4th:
+    print("")
+
+
+if __name__ == '__main__':
+    handlers = [_1st()]
+    for handler in handlers:
+        print("")
Index: leetcode_base/bank/_2336.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- leetcode_base/bank/_2336.py	(date 1687999554752)
+++ leetcode_base/bank/_2336.py	(date 1687999554752)
@@ -0,0 +1,23 @@
+from typing import List
+
+
+class _1st:
+    print("")
+
+
+class _2nd:
+    print("")
+
+
+class _3rd:
+    print("")
+
+
+class _4th:
+    print("")
+
+
+if __name__ == '__main__':
+    handlers = [_1st()]
+    for handler in handlers:
+        print("")
Index: expolre/basic/slots_test.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- expolre/basic/slots_test.py	(date 1701141002752)
+++ expolre/basic/slots_test.py	(date 1701141002752)
@@ -0,0 +1,48 @@
+import weakref
+
+"""
+理解 Python 类属性 __slots__
+https://zhuanlan.zhihu.com/p/294027322
+"""
+
+
+class X:
+    def __init__(self, a, b):
+        self.a = a
+        self.b = b
+
+
+class Y:
+    # __slots__ = ('a', 'b')
+    __slots__ = ('a', 'b', '__dict__', '__weakref__')
+
+    def __init__(self, a, b):
+        """
+        此时如果你声明一个 __slots__ 中没有的属性，如
+        self.c = 1
+        pylint 等就会提示错误：
+        [pylint] [Error] Assigning to attribute 'c' not defined in class slots
+        当然如果你执意要写的话，初始化实例的时候会引发 AttributeError：
+        AttributeError: 'Y' object has no attribute 'c'
+        """
+        self.a = a
+        self.b = b
+
+
+x = X(7, 8)
+print(x.a)
+x.c = 9
+print(x.__dict__)
+
+rx = weakref.ref(x)
+print(rx)
+
+y = Y(7, 8)
+print(y.a)
+# y.c = 9
+# AttributeError: 'Y' object has no attribute 'c'
+# print(y.__dict__)
+# AttributeError: 'Y' object has no attribute '__dict__'
+ry = weakref.ref(y)
+# print(ry)
+# TypeError: cannot create weak reference to 'Y' object
Index: leetcode_base/bank/_907.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- leetcode_base/bank/_907.py	(date 1701055419396)
+++ leetcode_base/bank/_907.py	(date 1701055419396)
@@ -0,0 +1,60 @@
+from typing import List
+
+
+class _1st:
+    def sumSubarrayMins(self, arr: List[int]) -> int:
+        n = len(arr)
+        # 左边界left[i]为左侧严格小于arr[i]的最近元素位置(不存在时为-1) 开区间
+        left, st = [-1] * n, []
+        for i, x in enumerate(arr):
+            while st and arr[st[-1]] >= x:
+                st.pop()
+            if st:
+                left[i] = st[-1]
+            st.append(i)
+
+        # 右边界right[i]为右侧小于等于arr[i]的最近元素位置(不存在时为n) 开区间
+        right, st = [n] * n, []
+        for i in range(n - 1, -1, -1):
+            while st and arr[st[-1]] > arr[i]:
+                st.pop()
+            if st:
+                right[i] = st[-1]
+            st.append(i)
+
+        ans = 0
+        for i, (x, l, r) in enumerate(zip(arr, left, right)):
+            ans += x * (i - l) * (r - i)
+        return ans % (10 ** 9 + 7)
+
+
+class _2nd:
+    def sumSubarrayMins(self, arr: List[int]) -> int:
+        n = len(arr)
+        # 左边界left[i]为左侧严格小于arr[i]的最近元素位置(不存在时为-1) 开区间
+        # 右边界right[i]为右侧小于等于arr[i]的最近元素位置(不存在时为n) 开区间
+        left, right, st = [-1] * n, [n] * n, []
+        for i, x in enumerate(arr):
+            while st and arr[st[-1]] >= x:
+                right[st.pop()] = i
+            if st:
+                left[i] = st[-1]
+            st.append(i)
+        ans = 0
+        for i, (x, l, r) in enumerate(zip(arr, left, right)):
+            ans += x * (i - l) * (r - i)
+        return ans % (10 ** 9 + 7)
+
+
+class _3rd:
+    print("")
+
+
+class _4th:
+    print("")
+
+
+if __name__ == '__main__':
+    handlers = [_1st()]
+    for handler in handlers:
+        print("")
